{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating Projectile Motion: Dependence of Range on Launch Angle Projectile motion, the movement of an object thrown at an angle to the horizontal, is a fundamental concept in physics. Understanding how the range of a projectile depends on the launch angle is not only mathematically intriguing but also has numerous real-world applications. This principle is widely used in various fields, from analyzing the flight of a soccer ball to calculating the trajectory of a spacecraft. 1. Theoretical Foundation I see you're asking about deriving the equations for projectile motion, specifically the range equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , as shown in the image. Let's go through the derivation step by step using the given equations of motion. We'll assume you're looking to derive the range \\( R \\) , since that's the final equation highlighted, but if you'd like to derive another part (like the time of flight), let me know! Step 1: Understand the Setup Projectile motion describes an object launched at an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) to the horizontal, under the influence of gravity \\( g \\) (with no air resistance). The motion can be broken into two independent components: - Horizontal motion (x-direction): Constant velocity, since there's no horizontal acceleration. - Vertical motion (y-direction): Accelerated motion due to gravity. The given equations are: - Horizontal position: \\( x = v_0 \\cos \\theta \\cdot t \\) - Vertical position: \\( y = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\) - Time of flight: \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) (when \\( y = 0 \\) , i.e., when the projectile returns to the ground) - Range: \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Our goal is to derive the range \\( R \\) . Step 2: Derive the Time of Flight First, we need the total time the projectile is in the air (time of flight). The projectile returns to the ground when its vertical position \\( y = 0 \\) . Use the vertical position equation: [ y = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 ] Set \\( y = 0 \\) (when the projectile lands): [ 0 = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 ] Factor out \\( t \\) : [ t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0 ] This gives two solutions: - \\( t = 0 \\) (the launch point) - \\( v_0 \\sin \\theta - \\frac{1}{2} g t = 0 \\) Solve the second equation: [ v_0 \\sin \\theta - \\frac{1}{2} g t = 0 ] [ \\frac{1}{2} g t = v_0 \\sin \\theta ] [ t = \\frac{v_0 \\sin \\theta}{\\frac{1}{2} g} = \\frac{2 v_0 \\sin \\theta}{g} ] This matches the given time of flight: [ t = \\frac{2 v_0 \\sin \\theta}{g} ] This is the total time the projectile is in the air. Step 3: Derive the Range \\( R \\) The range \\( R \\) is the horizontal distance traveled when the projectile lands, i.e., the value of \\( x \\) when \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) . Use the horizontal position equation: [ x = v_0 \\cos \\theta \\cdot t ] Substitute the time of flight \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) : [ R = x = v_0 \\cos \\theta \\cdot \\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) ] Simplify: [ R = \\frac{v_0 \\cdot 2 v_0 \\sin \\theta \\cos \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g} ] Now, use the trigonometric identity \\( \\sin(2\\theta) = 2 \\sin \\theta \\cos \\theta \\) : [ 2 \\sin \\theta \\cos \\theta = \\sin(2\\theta) ] Substitute this into the equation: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] This matches the given range equation: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] Step 4: Verify the Result The derived equation shows that the range depends on: - The square of the initial velocity ( \\( v_0^2 \\) ), - The sine of twice the launch angle ( \\( \\sin(2\\theta) \\) ), - The gravitational acceleration ( \\( g \\) ). This makes physical sense: - A higher initial velocity increases the range (since \\( v_0^2 \\) ). - The \\( \\sin(2\\theta) \\) term indicates that the range is maximized when \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) , which is a well-known result in projectile motion. - A larger \\( g \\) (e.g., on a planet with stronger gravity) reduces the range. Final Answer The range of the projectile is: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] This was derived by: 1. Finding the time of flight by setting the vertical position to zero. 2. Substituting the time of flight into the horizontal position equation. 3. Simplifying using the trigonometric identity \\( 2 \\sin \\theta \\cos \\theta = \\sin(2\\theta) \\) . If you'd like to derive any other part of the projectile motion equations (e.g., maximum height) or need a numerical example, let me know! 2. Range Analysis Based on Launch Angle Key observations: Maximum range occurs at $ \\theta = 45^\\circ $ (assuming no air resistance). Symmetry of trajectory: The same range is achieved at complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) result in the same range). Dependence on velocity: Since \\(R\\propto v_0^2\\) , doubling the initial velocity quadruples the range. Effect of gravity: On planets with lower gravity (e.g., the Moon, where \\(g \\approx 1.62\\) m/s\u00b2), projectiles travel much farther than on Earth. 3. Practical Applications of Projectile Motion Projectile motion plays a crucial role in various fields: Sports: Optimizing kick angles in soccer, basketball shots, and long jumps. Ballistics: Calculating bullet and missile trajectories. Engineering: Designing structures resistant to impact forces. Space Exploration: Determining launch trajectories for satellites and landers. However, real-world factors complicate the idealized model: - Air resistance reduces the range. - Uneven terrain affects the landing position. - Magnus effect (object spin) alters the trajectory (e.g., in soccer or tennis). 4. Implementation and Visualization with Code To gain a deeper understanding of projectile motion, Python can be used to compute and visualize the relationship between launch angle and range. import numpy as np import matplotlib.pyplot as plt def range_of_projectile(v0, theta, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Variable v0 = 20 # \u043c/\u0441 angles = np.linspace(0, 90, 100) ranges = [range_of_projectile(v0, theta) for theta in angles] # Graph plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} \u043c/\u0441') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() What does the provided script do? \u2705 Computes the range for angles from \\(0^\\circ\\) to \\(90^\\circ\\) . \u2705 Simulates the effect of different initial velocities. \u2705 Plots a graph of range vs. launch angle. If additional factors such as air resistance or variable gravity (e.g., Mars) need to be considered, the code can be extended. Would you like to incorporate such enhancements? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-projectile-motion-dependence-of-range-on-launch-angle","text":"Projectile motion, the movement of an object thrown at an angle to the horizontal, is a fundamental concept in physics. Understanding how the range of a projectile depends on the launch angle is not only mathematically intriguing but also has numerous real-world applications. This principle is widely used in various fields, from analyzing the flight of a soccer ball to calculating the trajectory of a spacecraft.","title":"Investigating Projectile Motion: Dependence of Range on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"I see you're asking about deriving the equations for projectile motion, specifically the range equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , as shown in the image. Let's go through the derivation step by step using the given equations of motion. We'll assume you're looking to derive the range \\( R \\) , since that's the final equation highlighted, but if you'd like to derive another part (like the time of flight), let me know!","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-understand-the-setup","text":"Projectile motion describes an object launched at an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) to the horizontal, under the influence of gravity \\( g \\) (with no air resistance). The motion can be broken into two independent components: - Horizontal motion (x-direction): Constant velocity, since there's no horizontal acceleration. - Vertical motion (y-direction): Accelerated motion due to gravity. The given equations are: - Horizontal position: \\( x = v_0 \\cos \\theta \\cdot t \\) - Vertical position: \\( y = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\) - Time of flight: \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) (when \\( y = 0 \\) , i.e., when the projectile returns to the ground) - Range: \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Our goal is to derive the range \\( R \\) .","title":"Step 1: Understand the Setup"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-derive-the-time-of-flight","text":"First, we need the total time the projectile is in the air (time of flight). The projectile returns to the ground when its vertical position \\( y = 0 \\) . Use the vertical position equation: [ y = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 ] Set \\( y = 0 \\) (when the projectile lands): [ 0 = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 ] Factor out \\( t \\) : [ t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0 ] This gives two solutions: - \\( t = 0 \\) (the launch point) - \\( v_0 \\sin \\theta - \\frac{1}{2} g t = 0 \\) Solve the second equation: [ v_0 \\sin \\theta - \\frac{1}{2} g t = 0 ] [ \\frac{1}{2} g t = v_0 \\sin \\theta ] [ t = \\frac{v_0 \\sin \\theta}{\\frac{1}{2} g} = \\frac{2 v_0 \\sin \\theta}{g} ] This matches the given time of flight: [ t = \\frac{2 v_0 \\sin \\theta}{g} ] This is the total time the projectile is in the air.","title":"Step 2: Derive the Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-derive-the-range-r","text":"The range \\( R \\) is the horizontal distance traveled when the projectile lands, i.e., the value of \\( x \\) when \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) . Use the horizontal position equation: [ x = v_0 \\cos \\theta \\cdot t ] Substitute the time of flight \\( t = \\frac{2 v_0 \\sin \\theta}{g} \\) : [ R = x = v_0 \\cos \\theta \\cdot \\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) ] Simplify: [ R = \\frac{v_0 \\cdot 2 v_0 \\sin \\theta \\cos \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g} ] Now, use the trigonometric identity \\( \\sin(2\\theta) = 2 \\sin \\theta \\cos \\theta \\) : [ 2 \\sin \\theta \\cos \\theta = \\sin(2\\theta) ] Substitute this into the equation: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] This matches the given range equation: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ]","title":"Step 3: Derive the Range \\( R \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-verify-the-result","text":"The derived equation shows that the range depends on: - The square of the initial velocity ( \\( v_0^2 \\) ), - The sine of twice the launch angle ( \\( \\sin(2\\theta) \\) ), - The gravitational acceleration ( \\( g \\) ). This makes physical sense: - A higher initial velocity increases the range (since \\( v_0^2 \\) ). - The \\( \\sin(2\\theta) \\) term indicates that the range is maximized when \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) , which is a well-known result in projectile motion. - A larger \\( g \\) (e.g., on a planet with stronger gravity) reduces the range.","title":"Step 4: Verify the Result"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#final-answer","text":"The range of the projectile is: [ R = \\frac{v_0^2 \\sin(2\\theta)}{g} ] This was derived by: 1. Finding the time of flight by setting the vertical position to zero. 2. Substituting the time of flight into the horizontal position equation. 3. Simplifying using the trigonometric identity \\( 2 \\sin \\theta \\cos \\theta = \\sin(2\\theta) \\) .","title":"Final Answer"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#if-youd-like-to-derive-any-other-part-of-the-projectile-motion-equations-eg-maximum-height-or-need-a-numerical-example-let-me-know","text":"","title":"If you'd like to derive any other part of the projectile motion equations (e.g., maximum height) or need a numerical example, let me know!"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis-based-on-launch-angle","text":"Key observations: Maximum range occurs at $ \\theta = 45^\\circ $ (assuming no air resistance). Symmetry of trajectory: The same range is achieved at complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) result in the same range). Dependence on velocity: Since \\(R\\propto v_0^2\\) , doubling the initial velocity quadruples the range. Effect of gravity: On planets with lower gravity (e.g., the Moon, where \\(g \\approx 1.62\\) m/s\u00b2), projectiles travel much farther than on Earth.","title":"2. Range Analysis Based on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications-of-projectile-motion","text":"Projectile motion plays a crucial role in various fields: Sports: Optimizing kick angles in soccer, basketball shots, and long jumps. Ballistics: Calculating bullet and missile trajectories. Engineering: Designing structures resistant to impact forces. Space Exploration: Determining launch trajectories for satellites and landers. However, real-world factors complicate the idealized model: - Air resistance reduces the range. - Uneven terrain affects the landing position. - Magnus effect (object spin) alters the trajectory (e.g., in soccer or tennis).","title":"3. Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-and-visualization-with-code","text":"To gain a deeper understanding of projectile motion, Python can be used to compute and visualize the relationship between launch angle and range. import numpy as np import matplotlib.pyplot as plt def range_of_projectile(v0, theta, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Variable v0 = 20 # \u043c/\u0441 angles = np.linspace(0, 90, 100) ranges = [range_of_projectile(v0, theta) for theta in angles] # Graph plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} \u043c/\u0441') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"4. Implementation and Visualization with Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#what-does-the-provided-script-do","text":"\u2705 Computes the range for angles from \\(0^\\circ\\) to \\(90^\\circ\\) . \u2705 Simulates the effect of different initial velocities. \u2705 Plots a graph of range vs. launch angle. If additional factors such as air resistance or variable gravity (e.g., Mars) need to be considered, the code can be extended. Would you like to incorporate such enhancements? \ud83d\ude80","title":"What does the provided script do?"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Step-by-Step Solution: Theoretical Foundation Step 1: Understand the Given Differential Equation The differential equation for a forced damped pendulum is provided as: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin \\theta = A \\cos(\\omega t) $$ Where: - \\(\\theta\\) : Angle of the pendulum from the vertical (in radians). - \\(\\frac{d^2\\theta}{dt^2}\\) : Angular acceleration. - \\(\\frac{b}{m}\\frac{d\\theta}{dt}\\) : Damping term, proportional to angular velocity, where \\(b\\) is the damping coefficient and $ m $ is the mass. - \\(\\frac{g}{l}\\sin\\theta\\) : Restoring force due to gravity, where $ g $ is the gravitational acceleration and $ l $ is the length of the pendulum. - \\(A\\cos(\\omega t)\\) : External periodic forcing with amplitude $ A $ and frequency \\(\\omega\\) . This equation is nonlinear due to the $ \\sin \\theta $ term, but the task asks for an approximate solution for small angles. Step 2: Apply the Small-Angle Approximation For small angles ($ \\theta \\ll 1 $), we can approximate: $$ \\sin \\theta \\approx \\theta $$ Substitute this into the differential equation: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{l} \\theta = A \\cos(\\omega t) $$ Define: - \\(\\gamma = \\frac{b}{m}\\) : Damping coefficient. - \\(\\omega_0^2 = \\frac{g}{l}\\) , where \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency of the undamped pendulum. The equation becomes: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ This is now a linear second-order differential equation with constant coefficients and a harmonic forcing term. Step 3: Solve the Homogeneous Equation First, solve the homogeneous part: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0 $$ The characteristic equation is: $$ r^2 + \\gamma r + \\omega_0^2 = 0 $$ Solve for \\(r\\) : $$ r = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 - 4 \\omega_0^2}}{2} $$ The discriminant is: $$ \\Delta = \\gamma^2 - 4 \\omega_0^2 $$ Assuming weak damping ( \\(\\gamma < 2 \\omega_0\\) , so \\(\\Delta < 0\\) ), the roots are complex: $$ r = -\\frac{\\gamma}{2} \\pm i \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} $$ Define the damped frequency: $$ \\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} $$ The homogeneous solution is: $$ \\theta_h(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) $$ This represents damped oscillations that decay over time. Step 4: Solve the Particular Solution (Forced Response) Now, solve the nonhomogeneous equation: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ Assume a particular solution of the form: $$ \\theta_p(t) = B \\cos(\\omega t) + C \\sin(\\omega t) $$ Compute the derivatives: - \\(\\frac{d\\theta_p}{dt} = -B \\omega \\sin(\\omega t) + C \\omega \\cos(\\omega t)\\) - \\(\\frac{d^2\\theta_p}{dt^2} = -B \\omega^2 \\cos(\\omega t) - C \\omega^2 \\sin(\\omega t)\\) Substitute into the equation: $$ (-B \\omega^2 \\cos(\\omega t) - C \\omega^2 \\sin(\\omega t)) + \\gamma (-B \\omega \\sin(\\omega t) + C \\omega \\cos(\\omega t)) + \\omega_0^2 (B \\cos(\\omega t) + C \\sin(\\omega t)) = A \\cos(\\omega t) $$ Equate coefficients of $\\cos(\\omega t) $ and $ \\sin(\\omega t)$: - For \\(\\cos(\\omega t)\\) : $$ -B \\omega^2 + \\gamma C \\omega + \\omega_0^2 B = A $$ $$ B (\\omega_0^2 - \\omega^2) + \\gamma C \\omega = A \\quad (1) $$ - For \\(\\sin(\\omega t)\\) : $$ -C \\omega^2 - \\gamma B \\omega + \\omega_0^2 C = 0 $$ $$ C (\\omega_0^2 - \\omega^2) - \\gamma B \\omega = 0 \\quad (2) $$ From (2): $$ C (\\omega_0^2 - \\omega^2) = \\gamma B \\omega $$ $$ C = \\frac{\\gamma B \\omega}{\\omega_0^2 - \\omega^2} $$ Substitute \\(C\\) into (1): $$ B (\\omega_0^2 - \\omega^2) + \\gamma \\left( \\frac{\\gamma B \\omega}{\\omega_0^2 - \\omega^2} \\right) \\omega = A $$ $$ B \\left( (\\omega_0^2 - \\omega^2) + \\frac{\\gamma^2 \\omega^2}{\\omega_0^2 - \\omega^2} \\right) = A $$ $$ B \\left( \\frac{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}{\\omega_0^2 - \\omega^2} \\right) = A $$ $$ B = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} $$ Now solve for \\(C\\) : $$ C = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\cdot \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} = \\frac{A \\gamma \\omega}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} $$ The particular solution is: $$ \\theta_p(t) = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} \\cos(\\omega t) + \\frac{A \\gamma \\omega}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} \\sin(\\omega t) $$ Rewrite in amplitude-phase form: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi) $$ Where: $$ D = \\sqrt{B^2 + C^2} = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} $$ $$ \\tan \\phi = \\frac{C}{B} = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} $$ Step 5: General Solution The general solution is the sum of the homogeneous and particular solutions: $$ \\theta(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\cos(\\omega t - \\phi) $$ The first term (homogeneous) decays over time, leaving the steady-state solution (particular) as the dominant behavior. Step 6: Resonance Conditions Resonance occurs when the amplitude \\(D\\) is maximized: $$ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} $$ The denominator is minimized when \\(\\omega \\approx \\omega_0\\) , i.e., the driving frequency matches the natural frequency. For small damping, this leads to a large amplitude, increasing the system\u2019s energy significantly. Solution Summary Forced Damped Pendulum: Small-Angle Approximation Solution Step 1: Differential Equation The equation is: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin \\theta = A \\cos(\\omega t) $$ Step 2: Small-Angle Approximation For small angles, \\(\\sin \\theta \\approx \\theta\\) , so: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\gamma = \\frac{b}{m}\\) , \\(\\omega_0^2 = \\frac{g}{l}\\) . Step 3: Homogeneous Solution Characteristic equation: \\(r^2 + \\gamma r + \\omega_0^2 = 0\\) Roots: \\(r = -\\frac{\\gamma}{2} \\pm i \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2}\\) Damped frequency: \\(\\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2}\\) Solution: \\(\\theta_h(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right)\\) Step 4: Particular Solution Assume: \\(\\theta_p(t) = B \\cos(\\omega t) + C \\sin(\\omega t)\\) Solve to find: $$ B = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}, \\quad C = \\frac{A \\gamma \\omega}{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2} $$ Amplitude-phase form: \\(\\theta_p(t) = D \\cos(\\omega t - \\phi)\\) , where: $$ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}}, \\quad \\tan \\phi = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} $$ Step 5: General Solution $$ \\theta(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\cos(\\omega t - \\phi) $$ Step 6: Resonance Resonance occurs at \\(\\omega \\approx \\omega_0\\) , maximizing the amplitude \\(D\\) . Python Code: Forced Damped Pendulum Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # Gravitational acceleration (m/s^2) l = 1.0 # Length of the pendulum (m) b = 0.5 # Damping coefficient (kg/s) m = 1.0 # Mass of the pendulum (kg) A = 1.0 # Amplitude of the driving force omega = 2.0 # Driving frequency (rad/s) # Define the system of first-order ODEs def forced_damped_pendulum(state, t, gamma, omega_0, A, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Constants gamma = b / m omega_0 = np.sqrt(g / l) # Time array t = np.linspace(0, 20, 1000) # Initial conditions: [theta(0), theta_dot(0)] state0 = [0.1, 0.0] # Solve the ODE solution = odeint(forced_damped_pendulum, state0, t, args=(gamma, omega_0, A, omega)) theta = solution[:, 0] theta_dot = solution[:, 1] # Plotting plt.figure(figsize=(12, 8)) # Plot theta vs time plt.subplot(2, 2, 1) plt.plot(t, theta, label='\u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.title('Angle vs Time') plt.grid(True) plt.legend() # Plot theta_dot vs time plt.subplot(2, 2, 2) plt.plot(t, theta_dot, label='d\u03b8/dt(t)', color='orange') plt.xlabel('Time (s)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Angular Velocity vs Time') plt.grid(True) plt.legend() # Phase portrait plt.subplot(2, 2, 3) plt.plot(theta, theta_dot, label='Phase Portrait') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity d\u03b8/dt (rad/s)') plt.title('Phase Portrait') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Explanation of the Code - Parameters : The script defines physical parameters like \\(g\\) , \\(l\\) , \\(b\\) , \\(m\\) , \\(A\\) , and \\(\\omega\\) . - ODE System : The nonlinear equation is converted into a system of first-order ODEs: \\(\\frac{d\\theta}{dt} = \\dot{\\theta}\\) , \\(\\frac{d\\dot{\\theta}}{dt} = -\\gamma \\dot{\\theta} - \\omega_0^2 \\sin \\theta + A \\cos(\\omega t)\\) . - Numerical Solution : The odeint function from SciPy uses an adaptive method (similar to Runge-Kutta) to solve the system. - Plots : The script generates three plots: \\(\\theta(t)\\) , \\(\\dot{\\theta}(t)\\) , and a phase portrait ( \\(\\dot{\\theta}\\) vs. \\(\\theta\\) ).","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Step-by-Step Solution: Orbital Period and Orbital Radius (Kepler's Third Law) Step 1: Derive the Relationship Between Orbital Period and Orbital Radius Kepler's Third Law states that the square of the orbital period of a planet is proportional to the cube of its average distance from the Sun (or the central body it orbits). Let's derive this relationship for circular orbits. Consider a planet of mass \\(m\\) orbiting a central body (e.g., the Sun) of mass \\(M\\) in a circular orbit with radius \\(r\\) . The gravitational force provides the centripetal force required for circular motion. Gravitational Force : The force between the planet and the central body is given by Newton's law of gravitation: $$ F = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, \\(m\\) is the mass of the planet, and \\(r\\) is the orbital radius. Centripetal Force : For circular motion, the centripetal force required to keep the planet in orbit is: $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity of the planet. Since the gravitational force provides the centripetal force: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ The \\(m\\) terms cancel out (assuming \\(m \\neq 0\\) ): $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ Multiply both sides by \\(r\\) : $$ \\frac{G M}{r} = v^2 $$ $$ v = \\sqrt{\\frac{G M}{r}} $$ Orbital Period : The orbital period \\(T\\) is the time it takes for the planet to complete one full orbit. The circumference of the circular orbit is \\(2\\pi r\\) , and the planet travels at speed \\(v\\) , so: $$ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2 \\pi r}{v} $$ Substitute \\(v = \\sqrt{\\frac{G M}{r}}\\) : $$ T = \\frac{2 \\pi r}{\\sqrt{\\frac{G M}{r}}} = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi r^{3/2} \\frac{1}{\\sqrt{G M}} $$ Simplify: $$ T = 2 \\pi \\sqrt{\\frac{r^3}{G M}} $$ Square both sides to get Kepler's Third Law: $$ T^2 = \\left( 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\right)^2 = 4 \\pi^2 \\frac{r^3}{G M} $$ Rearrange: $$ T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) r^3 $$ This shows that \\(T^2\\) is proportional to \\(r^3\\) , with the constant of proportionality \\(\\frac{4\\pi^2}{G M}\\) , which depends on the mass of the central body \\(M\\) . Step 2: Discuss the Implications for Planetary Motions Kepler's Third Law has significant implications for understanding planetary motions: - Uniformity Across Planets : For planets orbiting the same central body (e.g., the Sun), \\(G\\) and \\(M\\) are constant, so \\(T^2 \\propto r^3\\) . This allows us to compare the orbits of different planets. For example, if one planet is at a distance twice that of another, its orbital period will be \\(2^{3/2} = \\sqrt{8} \\approx 2.828\\) times longer. - Role of Masses : The mass of the central body \\(M\\) affects the orbital period, but the mass of the planet \\(m\\) does not (as it cancels out). This is why all planets, regardless of their mass, follow the same \\(T^2 \\propto r^3\\) relationship when orbiting the same star. - Applications : This law helps astronomers determine the mass of a central body by observing the periods and distances of orbiting objects (e.g., moons or planets). It also aids in predicting the orbital periods of artificial satellites. Step 3: Analyze Real-World Examples - Moon's Orbit Around Earth : The Moon orbits Earth at an average distance of approximately \\(r = 384,400\\,\\text{km}\\) with a period of about \\(T = 27.32\\,\\text{days}\\) . Using Kepler's Third Law, we can estimate Earth's mass: $$ T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) r^3 $$ Convert units: \\(r = 384,400\\,\\text{km} = 3.844 \\times 10^8\\,\\text{m}\\) , \\(T = 27.32\\,\\text{days} = 27.32 \\times 86,400\\,\\text{s} = 2.360 \\times 10^6\\,\\text{s}\\) , \\(G = 6.674 \\times 10^{-11}\\,\\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . $$ (2.360 \\times 10^6)^2 = \\frac{4 \\pi^2}{G M} (3.844 \\times 10^8)^3 $$ Solve for \\(M\\) : $$ M = \\frac{4 \\pi^2 (3.844 \\times 10^8)^3}{G (2.360 \\times 10^6)^2} $$ Compute numerically: \\(M \\approx 5.97 \\times 10^{24}\\,\\text{kg}\\) , which matches Earth's mass. - Planets in the Solar System : For Earth, \\(r = 1\\,\\text{AU} \\approx 1.496 \\times 10^{11}\\,\\text{m}\\) , \\(T = 1\\,\\text{year} \\approx 3.156 \\times 10^7\\,\\text{s}\\) . Using the Sun's mass \\(M \\approx 1.989 \\times 10^{30}\\,\\text{kg}\\) , we can verify Kepler's Third Law and extend it to other planets like Jupiter ( \\(r \\approx 5.2\\,\\text{AU}\\) ). Step 4: Implement a Computational Model Below is a Python script to simulate circular orbits and verify Kepler's Third Law by plotting \\(T^2\\) versus \\(r^3\\) for different orbital radii. Python Code: Orbital Period Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period T given radius r def orbital_period(r, G, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Range of orbital radii (in meters, from 0.5 AU to 5 AU) r = np.linspace(0.5 * 1.496e11, 5 * 1.496e11, 100) # Calculate T for each r T = orbital_period(r, G, M) # Calculate T^2 and r^3 for plotting T_squared = T**2 r_cubed = r**3 # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Verification of Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.legend() plt.show() # Print a few example values print(\"Example Orbital Periods:\") for i in range(0, 100, 20): r_au = r[i] / 1.496e11 # Convert to AU T_years = T[i] / (3.156e7) # Convert to years print(f\"r = {r_au:.2f} AU, T = {T_years:.2f} years\") Explanation of the Code - Constants : We define \\(G\\) and \\(M\\) (mass of the Sun) to compute the orbital period. - Function : The orbital_period function implements the formula \\(T = 2\\pi \\sqrt{\\frac{r^3}{G M}}\\) . - Simulation : We calculate \\(T\\) for a range of \\(r\\) values (from 0.5 AU to 5 AU), then plot \\(T^2\\) versus \\(r^3\\) to verify the linear relationship predicted by Kepler's Third Law. - Output : The plot should show a straight line, confirming \\(T^2 \\propto r^3\\) . We also print example values of \\(r\\) (in AU) and \\(T\\) (in years) for reference. Discussion: Extension to Elliptical Orbits and Other Celestial Bodies - Elliptical Orbits : Kepler's Third Law in its general form applies to elliptical orbits, where \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse: \\(T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) a^3\\) . This extends the law to all bound orbits, not just circular ones. - Other Systems : The law applies to any system where one body orbits another under gravitational attraction, such as moons around planets, binary stars, or exoplanets around their stars. For example, the moons of Jupiter (e.g., Io, Europa) follow the same relationship with Jupiter's mass. - Limitations : The derivation assumes the mass of the orbiting body is much smaller than the central body ( \\(m \\ll M\\) ). For systems like binary stars, a more general form of Kepler's Third Law is needed, accounting for the masses of both bodies.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Step-by-Step Solution: Orbital Period and Orbital Radius (Kepler's Third Law) Step 1: Derive the Relationship Between Orbital Period and Orbital Radius Kepler's Third Law states that the square of the orbital period of a planet is proportional to the cube of its average distance from the Sun (or the central body it orbits). Let's derive this relationship for circular orbits. Consider a planet of mass \\(m\\) orbiting a central body (e.g., the Sun) of mass \\(M\\) in a circular orbit with radius \\(r\\) . The gravitational force provides the centripetal force required for circular motion. Gravitational Force : The force between the planet and the central body is given by Newton's law of gravitation: $$ F = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, \\(m\\) is the mass of the planet, and \\(r\\) is the orbital radius. Centripetal Force : For circular motion, the centripetal force required to keep the planet in orbit is: $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity of the planet. Since the gravitational force provides the centripetal force: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ The \\(m\\) terms cancel out (assuming \\(m \\neq 0\\) ): $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ Multiply both sides by \\(r\\) : $$ \\frac{G M}{r} = v^2 $$ $$ v = \\sqrt{\\frac{G M}{r}} $$ Orbital Period : The orbital period \\(T\\) is the time it takes for the planet to complete one full orbit. The circumference of the circular orbit is \\(2\\pi r\\) , and the planet travels at speed \\(v\\) , so: $$ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2 \\pi r}{v} $$ Substitute \\(v = \\sqrt{\\frac{G M}{r}}\\) : $$ T = \\frac{2 \\pi r}{\\sqrt{\\frac{G M}{r}}} = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi r^{3/2} \\frac{1}{\\sqrt{G M}} $$ Simplify: $$ T = 2 \\pi \\sqrt{\\frac{r^3}{G M}} $$ Square both sides to get Kepler's Third Law: $$ T^2 = \\left( 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\right)^2 = 4 \\pi^2 \\frac{r^3}{G M} $$ Rearrange: $$ T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) r^3 $$ This shows that \\(T^2\\) is proportional to \\(r^3\\) , with the constant of proportionality \\(\\frac{4\\pi^2}{G M}\\) , which depends on the mass of the central body \\(M\\) . Step 2: Discuss the Implications for Planetary Motions Kepler's Third Law has significant implications for understanding planetary motions: - Uniformity Across Planets : For planets orbiting the same central body (e.g., the Sun), \\(G\\) and \\(M\\) are constant, so \\(T^2 \\propto r^3\\) . This allows us to compare the orbits of different planets. For example, if one planet is at a distance twice that of another, its orbital period will be \\(2^{3/2} = \\sqrt{8} \\approx 2.828\\) times longer. - Role of Masses : The mass of the central body \\(M\\) affects the orbital period, but the mass of the planet \\(m\\) does not (as it cancels out). This is why all planets, regardless of their mass, follow the same \\(T^2 \\propto r^3\\) relationship when orbiting the same star. - Applications : This law helps astronomers determine the mass of a central body by observing the periods and distances of orbiting objects (e.g., moons or planets). It also aids in predicting the orbital periods of artificial satellites. Step 3: Analyze Real-World Examples - Moon's Orbit Around Earth : The Moon orbits Earth at an average distance of approximately \\(r = 384,400\\,\\text{km}\\) with a period of about \\(T = 27.32\\,\\text{days}\\) . Using Kepler's Third Law, we can estimate Earth's mass: $$ T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) r^3 $$ Convert units: \\(r = 384,400\\,\\text{km} = 3.844 \\times 10^8\\,\\text{m}\\) , \\(T = 27.32\\,\\text{days} = 27.32 \\times 86,400\\,\\text{s} = 2.360 \\times 10^6\\,\\text{s}\\) , \\(G = 6.674 \\times 10^{-11}\\,\\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . $$ (2.360 \\times 10^6)^2 = \\frac{4 \\pi^2}{G M} (3.844 \\times 10^8)^3 $$ Solve for \\(M\\) : $$ M = \\frac{4 \\pi^2 (3.844 \\times 10^8)^3}{G (2.360 \\times 10^6)^2} $$ Compute numerically: \\(M \\approx 5.97 \\times 10^{24}\\,\\text{kg}\\) , which matches Earth's mass. - Planets in the Solar System : For Earth, \\(r = 1\\,\\text{AU} \\approx 1.496 \\times 10^{11}\\,\\text{m}\\) , \\(T = 1\\,\\text{year} \\approx 3.156 \\times 10^7\\,\\text{s}\\) . Using the Sun's mass \\(M \\approx 1.989 \\times 10^{30}\\,\\text{kg}\\) , we can verify Kepler's Third Law and extend it to other planets like Jupiter ( \\(r \\approx 5.2\\,\\text{AU}\\) ). Step 4: Implement a Computational Model Below is a Python script to simulate circular orbits and verify Kepler's Third Law by plotting \\(T^2\\) versus \\(r^3\\) for different orbital radii. Python Code: Orbital Period Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period T given radius r def orbital_period(r, G, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Range of orbital radii (in meters, from 0.5 AU to 5 AU) r = np.linspace(0.5 * 1.496e11, 5 * 1.496e11, 100) # Calculate T for each r T = orbital_period(r, G, M) # Calculate T^2 and r^3 for plotting T_squared = T**2 r_cubed = r**3 # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Verification of Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.legend() plt.show() # Print a few example values print(\"Example Orbital Periods:\") for i in range(0, 100, 20): r_au = r[i] / 1.496e11 # Convert to AU T_years = T[i] / (3.156e7) # Convert to years print(f\"r = {r_au:.2f} AU, T = {T_years:.2f} years\") Explanation of the Code - Constants : We define \\(G\\) and \\(M\\) (mass of the Sun) to compute the orbital period. - Function : The orbital_period function implements the formula \\(T = 2\\pi \\sqrt{\\frac{r^3}{G M}}\\) . - Simulation : We calculate \\(T\\) for a range of \\(r\\) values (from 0.5 AU to 5 AU), then plot \\(T^2\\) versus \\(r^3\\) to verify the linear relationship predicted by Kepler's Third Law. - Output : The plot should show a straight line, confirming \\(T^2 \\propto r^3\\) . We also print example values of \\(r\\) (in AU) and \\(T\\) (in years) for reference. Discussion: Extension to Elliptical Orbits and Other Celestial Bodies - Elliptical Orbits : Kepler's Third Law in its general form applies to elliptical orbits, where \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse: \\(T^2 = \\left( \\frac{4 \\pi^2}{G M} \\right) a^3\\) . This extends the law to all bound orbits, not just circular ones. - Other Systems : The law applies to any system where one body orbits another under gravitational attraction, such as moons around planets, binary stars, or exoplanets around their stars. For example, the moons of Jupiter (e.g., Io, Europa) follow the same relationship with Jupiter's mass. - Limitations : The derivation assumes the mass of the orbiting body is much smaller than the central body ( \\(m \\ll M\\) ). For systems like binary stars, a more general form of Kepler's Third Law is needed, accounting for the masses of both bodies.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities Detailed Solution in a Single Black Box Detailed Step-by-Step Solution: Escape Velocities and Cosmic Velocities Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning First Cosmic Velocity (Orbital Velocity) : This is the speed required for an object to maintain a circular orbit around a celestial body at a radius \\(r\\) from the body\u2019s center. It balances the gravitational force with the centripetal force needed for circular motion. For a low orbit (just above the surface), \\(r\\) is approximately the body\u2019s radius \\(R\\) . This velocity is crucial for satellites to achieve stable orbits, such as those in low Earth orbit (LEO). Second Cosmic Velocity (Escape Velocity) : This is the minimum speed an object needs to escape the gravitational pull of a celestial body, reaching infinity with zero residual velocity. It\u2019s derived using energy conservation, ensuring the object\u2019s kinetic energy overcomes the gravitational potential energy. This velocity is independent of the launch direction (ignoring atmospheric effects) and is essential for missions leaving a planet, such as lunar or interplanetary travel. Third Cosmic Velocity (Interstellar Escape Velocity) : This is the speed required to escape the gravitational influence of a star system (e.g., the Solar System) and travel into interstellar space. It assumes the object starts from an orbit around the star (e.g., Earth\u2019s orbit around the Sun). The object must first escape the planet\u2019s gravity and then achieve the additional speed to escape the star\u2019s gravity from that orbital position. Step 2: Mathematical Derivations and Parameters 2.1 First Cosmic Velocity (Circular Orbit) Consider an object of mass \\(m\\) in a circular orbit around a celestial body of mass \\(M\\) at radius \\(r\\) (distance from the center). The gravitational force provides the centripetal force required for circular motion. The gravitational force is: $$ F_{\\text{grav}} = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(m\\) is the mass of the orbiting object. The centripetal force required for circular motion at speed \\(v_1\\) is: $$ F_{\\text{centripetal}} = \\frac{m v_1^2}{r} $$ Equate the two forces: $$ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} $$ Cancel \\(m\\) (since \\(m \\neq 0\\) ): $$ \\frac{G M}{r^2} = \\frac{v_1^2}{r} $$ Multiply both sides by \\(r\\) to eliminate the denominator on the right: $$ \\frac{G M}{r} = v_1^2 $$ Solve for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ For an orbit just above the surface, \\(r \\approx R\\) , where \\(R\\) is the radius of the celestial body. Thus, the first cosmic velocity at the surface is: $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ 2.2 Second Cosmic Velocity (Escape Velocity) To escape the gravitational pull, the object\u2019s kinetic energy must equal the gravitational potential energy required to reach infinity. The gravitational potential energy at distance \\(r\\) from the center is: $$ U = -\\frac{G M m}{r} $$ At infinity, the potential energy is zero ( \\(U = 0\\) ). The kinetic energy of the object at launch is: $$ K = \\frac{1}{2} m v_2^2 $$ Using conservation of mechanical energy (initial energy at \\(r\\) equals energy at infinity): $$ K + U = 0 \\quad (\\text{at infinity, total energy is zero for minimum escape}) $$ $$ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 $$ Cancel \\(m\\) : $$ \\frac{1}{2} v_2^2 = \\frac{G M}{r} $$ Multiply both sides by 2: $$ v_2^2 = \\frac{2 G M}{r} $$ Solve for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{r}} $$ At the surface ( \\(r = R\\) ): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Compare with the first cosmic velocity: $$ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\sqrt{\\frac{G M}{R}} = \\sqrt{2} v_1 $$ The escape velocity is \\(\\sqrt{2}\\) times the orbital velocity at the same radius. 2.3 Third Cosmic Velocity (Escape from the Solar System) This velocity is more complex, as it involves escaping the Sun\u2019s gravity from Earth\u2019s orbit around the Sun. First, the object must escape Earth\u2019s gravity (using \\(v_2\\) ). Then, at Earth\u2019s orbital distance from the Sun ( \\(r_{\\text{Earth-Sun}} = 1\\,\\text{AU}\\) ), it must achieve the escape velocity from the Sun\u2019s gravitational field. Escape Velocity from the Sun at Earth\u2019s Orbit : The Sun\u2019s mass is \\(M_{\\text{Sun}}\\) , and the distance is \\(r_{\\text{Earth-Sun}}\\) . Using the escape velocity formula: $$ v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Earth\u2019s Orbital Velocity Around the Sun : Earth orbits the Sun in a nearly circular orbit, so its orbital velocity is the first cosmic velocity with respect to the Sun: $$ v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Third Cosmic Velocity : The third cosmic velocity \\(v_3\\) is the additional speed (relative to Earth) needed to increase the object\u2019s speed from \\(v_{\\text{Earth}}\\) to \\(v_{\\text{esc,Sun}}\\) , assuming the object is launched in the direction of Earth\u2019s orbital motion. The total speed required at Earth\u2019s orbit is \\(v_{\\text{esc,Sun}}\\) , but Earth is already moving at \\(v_{\\text{Earth}}\\) , so: $$ v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}} $$ Substitute the expressions: $$ v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Factor out the common term: $$ v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} \\left( \\sqrt{2} - 1 \\right) $$ Since \\(\\sqrt{2} - 1 \\approx 0.414\\) , the third cosmic velocity is approximately 41.4% of the Sun\u2019s orbital velocity at Earth\u2019s distance. 2.4 Parameters Affecting Velocities - \\(M\\) : Mass of the celestial body. A larger \\(M\\) increases both \\(v_1\\) and \\(v_2\\) (since they are proportional to \\(\\sqrt{M}\\) ). - \\(r\\) : Distance from the center (or radius \\(R\\) at the surface). A larger \\(r\\) decreases the velocities (since they are proportional to \\(\\frac{1}{\\sqrt{r}}\\) ). - \\(G\\) : Gravitational constant, a universal constant. For the third cosmic velocity, additional parameters are \\(M_{\\text{Sun}}\\) (Sun\u2019s mass) and \\(r_{\\text{Earth-Sun}}\\) (Earth\u2019s orbital radius), which affect the Sun\u2019s escape velocity and Earth\u2019s orbital velocity. Step 3: Calculate and Visualize for Earth, Mars, and Jupiter Let\u2019s compute these velocities for Earth, Mars, and Jupiter using their masses and radii: - Earth: \\(M = 5.972 \\times 10^{24}\\,\\text{kg}\\) , \\(R = 6371\\,\\text{km}\\) - Mars: \\(M = 6.417 \\times 10^{23}\\,\\text{kg}\\) , \\(R = 3390\\,\\text{km}\\) - Jupiter: \\(M = 1.898 \\times 10^{27}\\,\\text{kg}\\) , \\(R = 69911\\,\\text{km}\\) - Sun: \\(M_{\\text{Sun}} = 1.989 \\times 10^{30}\\,\\text{kg}\\) , \\(r_{\\text{Earth-Sun}} = 1.496 \\times 10^{11}\\,\\text{m}\\) (1 AU) - \\(G = 6.674 \\times 10^{-11}\\,\\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Python Code: Cosmic Velocities Calculation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) r_earth_sun = 1.496e11 # Earth-Sun distance (m) # Celestial bodies data: [mass (kg), radius (m)] bodies = { \"Earth\": [5.972e24, 6371e3], \"Mars\": [6.417e23, 3390e3], \"Jupiter\": [1.898e27, 69911e3] } # Calculate velocities v1_values = [] # First cosmic velocity (orbital) v2_values = [] # Second cosmic velocity (escape) v3_value = None # Third cosmic velocity (from Earth\u2019s orbit) for body, (M, R) in bodies.items(): # First cosmic velocity v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v1_values.append(v1) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s v2_values.append(v2) # Third cosmic velocity (from Earth\u2019s orbit around the Sun) v_esc_sun = np.sqrt(2 * G * M_sun / r_earth_sun) # Escape velocity from Sun at 1 AU v_earth = np.sqrt(G * M_sun / r_earth_sun) # Earth\u2019s orbital velocity v3 = (v_esc_sun - v_earth) / 1000 # Convert to km/s v3_value = v3 # Visualization bodies_names = list(bodies.keys()) x = np.arange(len(bodies_names)) plt.figure(figsize=(10, 6)) plt.bar(x - 0.2, v1_values, 0.4, label=\"First Cosmic Velocity (Orbital)\", color=\"blue\") plt.bar(x + 0.2, v2_values, 0.4, label=\"Second Cosmic Velocity (Escape)\", color=\"orange\") plt.axhline(y=v3_value, color=\"green\", linestyle=\"--\", label=f\"Third Cosmic Velocity (from Earth) = {v3_value:.2f} km/s\") plt.xticks(x, bodies_names) plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.legend() plt.grid(True) plt.show() # Print values print(\"Cosmic Velocities (km/s):\") for i, body in enumerate(bodies_names): print(f\"{body}:\") print(f\" First Cosmic Velocity: {v1_values[i]:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2_values[i]:.2f} km/s\") print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3_value:.2f} km/s\") Step 4: Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into orbit. For Earth, \\(v_1 \\approx 7.9\\,\\text{km/s}\\) at the surface, but at typical LEO altitudes (e.g., 400 km), it\u2019s slightly less due to the larger \\(r\\) . Satellites like those in the International Space Station (ISS) orbit at about 7.6 km/s. Second Cosmic Velocity : Critical for missions escaping a planet\u2019s gravity. For Earth, \\(v_2 \\approx 11.2\\,\\text{km/s}\\) . The Apollo missions needed to exceed this to reach the Moon. For Jupiter, the high escape velocity (59.5 km/s) makes missions like Juno challenging, requiring significant fuel. Third Cosmic Velocity : Relevant for interstellar missions. For Earth, \\(v_3 \\approx 16.7\\,\\text{km/s}\\) (relative to Earth\u2019s motion). Voyager 1 achieved this speed (with gravitational assists) to escape the Solar System, now traveling at about 17 km/s relative to the Sun. These velocities guide mission planning, fuel requirements, and trajectory design. Explanation of the Code - Data : Defines the masses and radii of Earth, Mars, and Jupiter, along with Solar System parameters ( \\(M_{\\text{Sun}}\\) , \\(r_{\\text{Earth-Sun}}\\) ). - Calculations : Computes \\(v_1\\) and \\(v_2\\) for each body using the derived formulas, and \\(v_3\\) for Earth\u2019s orbit around the Sun. Velocities are converted to km/s for readability. - Visualization : A bar chart compares \\(v_1\\) and \\(v_2\\) for each body, with a horizontal line for \\(v_3\\) . - Output : Prints the calculated velocities for clarity.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#detailed-solution-in-a-single-black-box","text":"Detailed Step-by-Step Solution: Escape Velocities and Cosmic Velocities Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning First Cosmic Velocity (Orbital Velocity) : This is the speed required for an object to maintain a circular orbit around a celestial body at a radius \\(r\\) from the body\u2019s center. It balances the gravitational force with the centripetal force needed for circular motion. For a low orbit (just above the surface), \\(r\\) is approximately the body\u2019s radius \\(R\\) . This velocity is crucial for satellites to achieve stable orbits, such as those in low Earth orbit (LEO). Second Cosmic Velocity (Escape Velocity) : This is the minimum speed an object needs to escape the gravitational pull of a celestial body, reaching infinity with zero residual velocity. It\u2019s derived using energy conservation, ensuring the object\u2019s kinetic energy overcomes the gravitational potential energy. This velocity is independent of the launch direction (ignoring atmospheric effects) and is essential for missions leaving a planet, such as lunar or interplanetary travel. Third Cosmic Velocity (Interstellar Escape Velocity) : This is the speed required to escape the gravitational influence of a star system (e.g., the Solar System) and travel into interstellar space. It assumes the object starts from an orbit around the star (e.g., Earth\u2019s orbit around the Sun). The object must first escape the planet\u2019s gravity and then achieve the additional speed to escape the star\u2019s gravity from that orbital position. Step 2: Mathematical Derivations and Parameters 2.1 First Cosmic Velocity (Circular Orbit) Consider an object of mass \\(m\\) in a circular orbit around a celestial body of mass \\(M\\) at radius \\(r\\) (distance from the center). The gravitational force provides the centripetal force required for circular motion. The gravitational force is: $$ F_{\\text{grav}} = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(m\\) is the mass of the orbiting object. The centripetal force required for circular motion at speed \\(v_1\\) is: $$ F_{\\text{centripetal}} = \\frac{m v_1^2}{r} $$ Equate the two forces: $$ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} $$ Cancel \\(m\\) (since \\(m \\neq 0\\) ): $$ \\frac{G M}{r^2} = \\frac{v_1^2}{r} $$ Multiply both sides by \\(r\\) to eliminate the denominator on the right: $$ \\frac{G M}{r} = v_1^2 $$ Solve for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ For an orbit just above the surface, \\(r \\approx R\\) , where \\(R\\) is the radius of the celestial body. Thus, the first cosmic velocity at the surface is: $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ 2.2 Second Cosmic Velocity (Escape Velocity) To escape the gravitational pull, the object\u2019s kinetic energy must equal the gravitational potential energy required to reach infinity. The gravitational potential energy at distance \\(r\\) from the center is: $$ U = -\\frac{G M m}{r} $$ At infinity, the potential energy is zero ( \\(U = 0\\) ). The kinetic energy of the object at launch is: $$ K = \\frac{1}{2} m v_2^2 $$ Using conservation of mechanical energy (initial energy at \\(r\\) equals energy at infinity): $$ K + U = 0 \\quad (\\text{at infinity, total energy is zero for minimum escape}) $$ $$ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 $$ Cancel \\(m\\) : $$ \\frac{1}{2} v_2^2 = \\frac{G M}{r} $$ Multiply both sides by 2: $$ v_2^2 = \\frac{2 G M}{r} $$ Solve for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{r}} $$ At the surface ( \\(r = R\\) ): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Compare with the first cosmic velocity: $$ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\sqrt{\\frac{G M}{R}} = \\sqrt{2} v_1 $$ The escape velocity is \\(\\sqrt{2}\\) times the orbital velocity at the same radius. 2.3 Third Cosmic Velocity (Escape from the Solar System) This velocity is more complex, as it involves escaping the Sun\u2019s gravity from Earth\u2019s orbit around the Sun. First, the object must escape Earth\u2019s gravity (using \\(v_2\\) ). Then, at Earth\u2019s orbital distance from the Sun ( \\(r_{\\text{Earth-Sun}} = 1\\,\\text{AU}\\) ), it must achieve the escape velocity from the Sun\u2019s gravitational field. Escape Velocity from the Sun at Earth\u2019s Orbit : The Sun\u2019s mass is \\(M_{\\text{Sun}}\\) , and the distance is \\(r_{\\text{Earth-Sun}}\\) . Using the escape velocity formula: $$ v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Earth\u2019s Orbital Velocity Around the Sun : Earth orbits the Sun in a nearly circular orbit, so its orbital velocity is the first cosmic velocity with respect to the Sun: $$ v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Third Cosmic Velocity : The third cosmic velocity \\(v_3\\) is the additional speed (relative to Earth) needed to increase the object\u2019s speed from \\(v_{\\text{Earth}}\\) to \\(v_{\\text{esc,Sun}}\\) , assuming the object is launched in the direction of Earth\u2019s orbital motion. The total speed required at Earth\u2019s orbit is \\(v_{\\text{esc,Sun}}\\) , but Earth is already moving at \\(v_{\\text{Earth}}\\) , so: $$ v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}} $$ Substitute the expressions: $$ v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} $$ Factor out the common term: $$ v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} \\left( \\sqrt{2} - 1 \\right) $$ Since \\(\\sqrt{2} - 1 \\approx 0.414\\) , the third cosmic velocity is approximately 41.4% of the Sun\u2019s orbital velocity at Earth\u2019s distance. 2.4 Parameters Affecting Velocities - \\(M\\) : Mass of the celestial body. A larger \\(M\\) increases both \\(v_1\\) and \\(v_2\\) (since they are proportional to \\(\\sqrt{M}\\) ). - \\(r\\) : Distance from the center (or radius \\(R\\) at the surface). A larger \\(r\\) decreases the velocities (since they are proportional to \\(\\frac{1}{\\sqrt{r}}\\) ). - \\(G\\) : Gravitational constant, a universal constant. For the third cosmic velocity, additional parameters are \\(M_{\\text{Sun}}\\) (Sun\u2019s mass) and \\(r_{\\text{Earth-Sun}}\\) (Earth\u2019s orbital radius), which affect the Sun\u2019s escape velocity and Earth\u2019s orbital velocity. Step 3: Calculate and Visualize for Earth, Mars, and Jupiter Let\u2019s compute these velocities for Earth, Mars, and Jupiter using their masses and radii: - Earth: \\(M = 5.972 \\times 10^{24}\\,\\text{kg}\\) , \\(R = 6371\\,\\text{km}\\) - Mars: \\(M = 6.417 \\times 10^{23}\\,\\text{kg}\\) , \\(R = 3390\\,\\text{km}\\) - Jupiter: \\(M = 1.898 \\times 10^{27}\\,\\text{kg}\\) , \\(R = 69911\\,\\text{km}\\) - Sun: \\(M_{\\text{Sun}} = 1.989 \\times 10^{30}\\,\\text{kg}\\) , \\(r_{\\text{Earth-Sun}} = 1.496 \\times 10^{11}\\,\\text{m}\\) (1 AU) - \\(G = 6.674 \\times 10^{-11}\\,\\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Python Code: Cosmic Velocities Calculation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) r_earth_sun = 1.496e11 # Earth-Sun distance (m) # Celestial bodies data: [mass (kg), radius (m)] bodies = { \"Earth\": [5.972e24, 6371e3], \"Mars\": [6.417e23, 3390e3], \"Jupiter\": [1.898e27, 69911e3] } # Calculate velocities v1_values = [] # First cosmic velocity (orbital) v2_values = [] # Second cosmic velocity (escape) v3_value = None # Third cosmic velocity (from Earth\u2019s orbit) for body, (M, R) in bodies.items(): # First cosmic velocity v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v1_values.append(v1) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s v2_values.append(v2) # Third cosmic velocity (from Earth\u2019s orbit around the Sun) v_esc_sun = np.sqrt(2 * G * M_sun / r_earth_sun) # Escape velocity from Sun at 1 AU v_earth = np.sqrt(G * M_sun / r_earth_sun) # Earth\u2019s orbital velocity v3 = (v_esc_sun - v_earth) / 1000 # Convert to km/s v3_value = v3 # Visualization bodies_names = list(bodies.keys()) x = np.arange(len(bodies_names)) plt.figure(figsize=(10, 6)) plt.bar(x - 0.2, v1_values, 0.4, label=\"First Cosmic Velocity (Orbital)\", color=\"blue\") plt.bar(x + 0.2, v2_values, 0.4, label=\"Second Cosmic Velocity (Escape)\", color=\"orange\") plt.axhline(y=v3_value, color=\"green\", linestyle=\"--\", label=f\"Third Cosmic Velocity (from Earth) = {v3_value:.2f} km/s\") plt.xticks(x, bodies_names) plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.legend() plt.grid(True) plt.show() # Print values print(\"Cosmic Velocities (km/s):\") for i, body in enumerate(bodies_names): print(f\"{body}:\") print(f\" First Cosmic Velocity: {v1_values[i]:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2_values[i]:.2f} km/s\") print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3_value:.2f} km/s\") Step 4: Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into orbit. For Earth, \\(v_1 \\approx 7.9\\,\\text{km/s}\\) at the surface, but at typical LEO altitudes (e.g., 400 km), it\u2019s slightly less due to the larger \\(r\\) . Satellites like those in the International Space Station (ISS) orbit at about 7.6 km/s. Second Cosmic Velocity : Critical for missions escaping a planet\u2019s gravity. For Earth, \\(v_2 \\approx 11.2\\,\\text{km/s}\\) . The Apollo missions needed to exceed this to reach the Moon. For Jupiter, the high escape velocity (59.5 km/s) makes missions like Juno challenging, requiring significant fuel. Third Cosmic Velocity : Relevant for interstellar missions. For Earth, \\(v_3 \\approx 16.7\\,\\text{km/s}\\) (relative to Earth\u2019s motion). Voyager 1 achieved this speed (with gravitational assists) to escape the Solar System, now traveling at about 17 km/s relative to the Sun. These velocities guide mission planning, fuel requirements, and trajectory design. Explanation of the Code - Data : Defines the masses and radii of Earth, Mars, and Jupiter, along with Solar System parameters ( \\(M_{\\text{Sun}}\\) , \\(r_{\\text{Earth-Sun}}\\) ). - Calculations : Computes \\(v_1\\) and \\(v_2\\) for each body using the derived formulas, and \\(v_3\\) for Earth\u2019s orbit around the Sun. Velocities are converted to km/s for readability. - Visualization : A bar chart compares \\(v_1\\) and \\(v_2\\) for each body, with a horizontal line for \\(v_3\\) . - Output : Prints the calculated velocities for clarity.","title":"Detailed Solution in a Single Black Box"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Detailed Solution in a Single Black Box Detailed Step-by-Step Solution: Trajectories of a Freely Released Payload Near Earth Step 1: Analyze Possible Trajectories When a payload is released from a moving rocket near Earth, its trajectory depends on its initial position, velocity, and Earth\u2019s gravitational field. The trajectory type is determined by the specific energy \\(\\epsilon\\) and angular momentum, leading to three possible outcomes: - Elliptical Trajectory : The payload follows a bound orbit (ellipse or circle) if the total energy is negative. - Parabolic Trajectory : The payload escapes to infinity with zero velocity at infinity if the total energy is zero. - Hyperbolic Trajectory : The payload escapes to infinity with excess velocity if the total energy is positive. The specific energy \\(\\epsilon\\) (energy per unit mass) is: $$ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} $$ where \\(v\\) is the payload\u2019s speed, \\(r\\) is its distance from Earth\u2019s center, \\(M\\) is Earth\u2019s mass, and \\(G\\) is the gravitational constant. - \\(\\epsilon < 0\\) : Elliptical orbit (bound). - \\(\\epsilon = 0\\) : Parabolic trajectory (marginal escape). - \\(\\epsilon > 0\\) : Hyperbolic trajectory (escape with excess speed). To derive this, consider the total mechanical energy per unit mass. The kinetic energy per unit mass is: $$ \\frac{1}{2} v^2 $$ The gravitational potential energy per unit mass at distance \\(r\\) is: $$ -\\frac{G M}{r} $$ Thus, the specific energy is: $$ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} $$ At the escape velocity, \\(\\epsilon = 0\\) , which gives: $$ \\frac{v^2}{2} = \\frac{G M}{r} \\quad \\Rightarrow \\quad v = \\sqrt{\\frac{2 G M}{r}} $$ This matches the second cosmic velocity derived earlier, confirming that \\(\\epsilon = 0\\) corresponds to a parabolic trajectory. Step 2: Numerical Analysis of the Payload\u2019s Path The motion is governed by Newton\u2019s law of gravitation in vector form: $$ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^3} \\vec{r} $$ where \\(\\vec{r}\\) is the position vector from Earth\u2019s center to the payload, and \\(r = |\\vec{r}|\\) . In Cartesian coordinates, \\(\\vec{r} = (x, y)\\) (assuming 2D motion in the orbital plane), so: $$ r = \\sqrt{x^2 + y^2} $$ The acceleration components are: $$ \\frac{d^2 x}{dt^2} = -\\frac{G M x}{r^3}, \\quad \\frac{d^2 y}{dt^2} = -\\frac{G M y}{r^3} $$ To solve numerically, convert this second-order system into a system of first-order ODEs. Define the state vector as \\((x, y, v_x, v_y)\\) , where \\(v_x = \\frac{dx}{dt}\\) and \\(v_y = \\frac{dy}{dt}\\) . The system becomes: $$ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{G M x}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{G M y}{r^3} $$ We\u2019ll use the gravitational parameter \\(\\mu = G M\\) for numerical efficiency, where \\(\\mu\\) combines \\(G\\) and \\(M\\) into a single constant. Step 3: Relate Trajectories to Orbital Scenarios Orbital Insertion : If the payload\u2019s velocity matches the first cosmic velocity at its altitude, it enters a circular orbit. For example, at 400 km altitude, the circular velocity is: $$ v_{\\text{circular}} = \\sqrt{\\frac{\\mu}{r}} $$ If the velocity is less, the orbit becomes elliptical with the release point as the apogee. If greater but still \\(\\epsilon < 0\\) , the orbit is elliptical with the release point as the perigee. Reentry : If the trajectory intersects Earth\u2019s surface (or atmosphere), the payload reenters. For an elliptical orbit, if the perigee is below Earth\u2019s surface ( \\(r_{\\text{perigee}} < R\\) ), the payload will collide with Earth. Escape : If the velocity exceeds the escape velocity at that altitude: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 \\mu}{r}} $$ the trajectory becomes parabolic ( \\(\\epsilon = 0\\) ) or hyperbolic ( \\(\\epsilon > 0\\) ), and the payload escapes Earth\u2019s gravity. Step 4: Computational Tool to Simulate and Visualize We\u2019ll simulate the payload\u2019s motion at an altitude of 400 km (typical for LEO) with initial velocities below, at, and above the circular velocity to observe different trajectories. Python Code: Payload Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth\u2019s mass (kg) R = 6371e3 # Earth\u2019s radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # Initial conditions: Released at 400 km altitude h = 400e3 # Altitude (m) r0 = R + h # Initial distance from Earth\u2019s center (m) x0, y0 = r0, 0 # Start on x-axis v_circular = np.sqrt(mu / r0) # Circular orbit velocity at this altitude v_escape = np.sqrt(2 * mu / r0) # Escape velocity at this altitude # Test different initial velocities: below, at, and above circular velocity v0_factors = [0.8, 1.0, 1.2] # Multipliers for circular velocity trajectories = [] # Time array t = np.linspace(0, 7200, 1000) # 2 hours # System of ODEs def payload_motion(state, t, mu): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Simulate for each initial velocity for factor in v0_factors: v0 = factor * v_circular state0 = [x0, y0, 0, v0] # Initial velocity in y-direction (tangential) solution = odeint(payload_motion, state0, t, args=(mu,)) trajectories.append(solution) # Plot trajectories plt.figure(figsize=(10, 8)) for i, traj in enumerate(trajectories): label = f\"v0 = {v0_factors[i]*v_circular/1000:.1f} km/s\" plt.plot(traj[:, 0]/1000, traj[:, 1]/1000, label=label) # Plot Earth theta = np.linspace(0, 2*np.pi, 100) plt.plot(R/1000 * np.cos(theta), R/1000 * np.sin(theta), \"b-\", label=\"Earth\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() # Calculate specific energy to classify trajectories print(\"Trajectory Classification:\") print(f\"Circular Velocity at {h/1000} km: {v_circular/1000:.1f} km/s\") print(f\"Escape Velocity at {h/1000} km: {v_escape/1000:.1f} km/s\") for i, factor in enumerate(v0_factors): v0 = factor * v_circular r = r0 epsilon = v0**2 / 2 - mu / r if epsilon < 0: traj_type = \"Elliptical\" elif abs(epsilon) < 1e-3: # Small threshold for numerical precision traj_type = \"Parabolic\" else: traj_type = \"Hyperbolic\" print(f\"v0 = {v0/1000:.1f} km/s: Energy = {epsilon:.2e} J/kg, Trajectory = {traj_type}\") Explanation of the Code - Setup : The payload is released at 400 km altitude, where \\(r = R + h\\) . The circular velocity \\(v_{\\text{circular}}\\) and escape velocity \\(v_{\\text{escape}}\\) are computed at this altitude. Initial velocities are set as 0.8, 1.0, and 1.2 times the circular velocity. - Simulation : The odeint function solves the system of ODEs, integrating over 2 hours to capture the trajectory shapes. - Visualization : Plots the trajectories in the x-y plane, with Earth shown for scale. The aspect ratio is set to equal to ensure accurate representation. - Classification : Computes the specific energy \\(\\epsilon\\) for each trajectory to classify it as elliptical, parabolic, or hyperbolic.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#detailed-solution-in-a-single-black-box","text":"Detailed Step-by-Step Solution: Trajectories of a Freely Released Payload Near Earth Step 1: Analyze Possible Trajectories When a payload is released from a moving rocket near Earth, its trajectory depends on its initial position, velocity, and Earth\u2019s gravitational field. The trajectory type is determined by the specific energy \\(\\epsilon\\) and angular momentum, leading to three possible outcomes: - Elliptical Trajectory : The payload follows a bound orbit (ellipse or circle) if the total energy is negative. - Parabolic Trajectory : The payload escapes to infinity with zero velocity at infinity if the total energy is zero. - Hyperbolic Trajectory : The payload escapes to infinity with excess velocity if the total energy is positive. The specific energy \\(\\epsilon\\) (energy per unit mass) is: $$ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} $$ where \\(v\\) is the payload\u2019s speed, \\(r\\) is its distance from Earth\u2019s center, \\(M\\) is Earth\u2019s mass, and \\(G\\) is the gravitational constant. - \\(\\epsilon < 0\\) : Elliptical orbit (bound). - \\(\\epsilon = 0\\) : Parabolic trajectory (marginal escape). - \\(\\epsilon > 0\\) : Hyperbolic trajectory (escape with excess speed). To derive this, consider the total mechanical energy per unit mass. The kinetic energy per unit mass is: $$ \\frac{1}{2} v^2 $$ The gravitational potential energy per unit mass at distance \\(r\\) is: $$ -\\frac{G M}{r} $$ Thus, the specific energy is: $$ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} $$ At the escape velocity, \\(\\epsilon = 0\\) , which gives: $$ \\frac{v^2}{2} = \\frac{G M}{r} \\quad \\Rightarrow \\quad v = \\sqrt{\\frac{2 G M}{r}} $$ This matches the second cosmic velocity derived earlier, confirming that \\(\\epsilon = 0\\) corresponds to a parabolic trajectory. Step 2: Numerical Analysis of the Payload\u2019s Path The motion is governed by Newton\u2019s law of gravitation in vector form: $$ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{G M}{r^3} \\vec{r} $$ where \\(\\vec{r}\\) is the position vector from Earth\u2019s center to the payload, and \\(r = |\\vec{r}|\\) . In Cartesian coordinates, \\(\\vec{r} = (x, y)\\) (assuming 2D motion in the orbital plane), so: $$ r = \\sqrt{x^2 + y^2} $$ The acceleration components are: $$ \\frac{d^2 x}{dt^2} = -\\frac{G M x}{r^3}, \\quad \\frac{d^2 y}{dt^2} = -\\frac{G M y}{r^3} $$ To solve numerically, convert this second-order system into a system of first-order ODEs. Define the state vector as \\((x, y, v_x, v_y)\\) , where \\(v_x = \\frac{dx}{dt}\\) and \\(v_y = \\frac{dy}{dt}\\) . The system becomes: $$ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{G M x}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{G M y}{r^3} $$ We\u2019ll use the gravitational parameter \\(\\mu = G M\\) for numerical efficiency, where \\(\\mu\\) combines \\(G\\) and \\(M\\) into a single constant. Step 3: Relate Trajectories to Orbital Scenarios Orbital Insertion : If the payload\u2019s velocity matches the first cosmic velocity at its altitude, it enters a circular orbit. For example, at 400 km altitude, the circular velocity is: $$ v_{\\text{circular}} = \\sqrt{\\frac{\\mu}{r}} $$ If the velocity is less, the orbit becomes elliptical with the release point as the apogee. If greater but still \\(\\epsilon < 0\\) , the orbit is elliptical with the release point as the perigee. Reentry : If the trajectory intersects Earth\u2019s surface (or atmosphere), the payload reenters. For an elliptical orbit, if the perigee is below Earth\u2019s surface ( \\(r_{\\text{perigee}} < R\\) ), the payload will collide with Earth. Escape : If the velocity exceeds the escape velocity at that altitude: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 \\mu}{r}} $$ the trajectory becomes parabolic ( \\(\\epsilon = 0\\) ) or hyperbolic ( \\(\\epsilon > 0\\) ), and the payload escapes Earth\u2019s gravity. Step 4: Computational Tool to Simulate and Visualize We\u2019ll simulate the payload\u2019s motion at an altitude of 400 km (typical for LEO) with initial velocities below, at, and above the circular velocity to observe different trajectories. Python Code: Payload Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth\u2019s mass (kg) R = 6371e3 # Earth\u2019s radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # Initial conditions: Released at 400 km altitude h = 400e3 # Altitude (m) r0 = R + h # Initial distance from Earth\u2019s center (m) x0, y0 = r0, 0 # Start on x-axis v_circular = np.sqrt(mu / r0) # Circular orbit velocity at this altitude v_escape = np.sqrt(2 * mu / r0) # Escape velocity at this altitude # Test different initial velocities: below, at, and above circular velocity v0_factors = [0.8, 1.0, 1.2] # Multipliers for circular velocity trajectories = [] # Time array t = np.linspace(0, 7200, 1000) # 2 hours # System of ODEs def payload_motion(state, t, mu): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Simulate for each initial velocity for factor in v0_factors: v0 = factor * v_circular state0 = [x0, y0, 0, v0] # Initial velocity in y-direction (tangential) solution = odeint(payload_motion, state0, t, args=(mu,)) trajectories.append(solution) # Plot trajectories plt.figure(figsize=(10, 8)) for i, traj in enumerate(trajectories): label = f\"v0 = {v0_factors[i]*v_circular/1000:.1f} km/s\" plt.plot(traj[:, 0]/1000, traj[:, 1]/1000, label=label) # Plot Earth theta = np.linspace(0, 2*np.pi, 100) plt.plot(R/1000 * np.cos(theta), R/1000 * np.sin(theta), \"b-\", label=\"Earth\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() # Calculate specific energy to classify trajectories print(\"Trajectory Classification:\") print(f\"Circular Velocity at {h/1000} km: {v_circular/1000:.1f} km/s\") print(f\"Escape Velocity at {h/1000} km: {v_escape/1000:.1f} km/s\") for i, factor in enumerate(v0_factors): v0 = factor * v_circular r = r0 epsilon = v0**2 / 2 - mu / r if epsilon < 0: traj_type = \"Elliptical\" elif abs(epsilon) < 1e-3: # Small threshold for numerical precision traj_type = \"Parabolic\" else: traj_type = \"Hyperbolic\" print(f\"v0 = {v0/1000:.1f} km/s: Energy = {epsilon:.2e} J/kg, Trajectory = {traj_type}\") Explanation of the Code - Setup : The payload is released at 400 km altitude, where \\(r = R + h\\) . The circular velocity \\(v_{\\text{circular}}\\) and escape velocity \\(v_{\\text{escape}}\\) are computed at this altitude. Initial velocities are set as 0.8, 1.0, and 1.2 times the circular velocity. - Simulation : The odeint function solves the system of ODEs, integrating over 2 hours to capture the trajectory shapes. - Visualization : Plots the trajectories in the x-y plane, with Earth shown for scale. The aspect ratio is set to equal to ensure accurate representation. - Classification : Computes the specific energy \\(\\epsilon\\) for each trajectory to classify it as elliptical, parabolic, or hyperbolic.","title":"Detailed Solution in a Single Black Box"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Explanation of the Topic: Interference Patterns on a Water Surface Main Topic: What is Interference? Interference is a phenomenon that occurs when two or more waves overlap. In this task, we are dealing with waves on the surface of water, created by point sources (e.g., like dropping several pebbles into the water). When waves from different sources meet, they can either reinforce each other (constructive interference) or cancel each other out (destructive interference). This creates patterns on the water\u2014regions where the water oscillates strongly and regions where it remains almost still. Real-Life Example: If you drop two pebbles into a pond, circular waves will spread out from each pebble. In places where the crests of the waves align, the water will rise significantly (constructive interference). Where a crest from one wave meets a trough from another, the water will remain nearly still (destructive interference). This forms an interference pattern. Wave Equation and Variables The task provides the equation for a wave generated by a single source: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Let\u2019s break down the variables and symbols: - \\(\\eta(x, y, t)\\) \u2014 This is the height of the wave (in meters) at a point with coordinates \\((x, y)\\) on the water surface at time \\(t\\) . It represents how much the water has risen or fallen due to the wave. - \\(A\\) \u2014 The amplitude of the wave (in meters). This is the maximum height of the wave near the source. A larger \\(A\\) means a stronger wave. - \\(r\\) \u2014 The distance from the wave source to the point \\((x, y)\\) (in meters). If the source is at \\((x_0, y_0)\\) , then: $$ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $$ - \\(\\frac{A}{\\sqrt{r}}\\) \u2014 The amplitude of the wave decreases with distance. Dividing by \\(\\sqrt{r}\\) accounts for the fact that the wave\u2019s energy spreads over a circular wavefront, so its intensity decreases with distance. - \\(k\\) \u2014 The wave number (in radians per meter, rad/m). It is related to the wavelength \\(\\lambda\\) (the distance between two crests): $$ k = \\frac{2\\pi}{\\lambda} $$ A smaller wavelength means a larger \\(k\\) , resulting in more frequent waves. - \\(\\omega\\) \u2014 The angular frequency (in radians per second, rad/s). It is related to the frequency \\(f\\) (the number of crests passing a point per second): $$ \\omega = 2\\pi f $$ A larger \\(\\omega\\) means the wave oscillates faster. - \\(t\\) \u2014 Time (in seconds). - \\(\\phi\\) \u2014 The initial phase (in radians). This is the starting shift of the wave. If \\(\\phi = 0\\) , the wave starts at its maximum. If \\(\\phi = \\pi\\) , it starts at its minimum. - \\(kr - \\omega t + \\phi\\) \u2014 The phase of the wave. It determines the stage of oscillation at point \\((x, y)\\) at time \\(t\\) . If the phase is \\(0\\) or \\(2\\pi\\) , it\u2019s a crest; if it\u2019s \\(\\pi\\) , it\u2019s a trough. - \\(\\cos(kr - \\omega t + \\phi)\\) \u2014 The cosine function describes the wave\u2019s oscillation. Since cosine varies from \\(-1\\) to \\(1\\) , the wave height varies from \\(-\\frac{A}{\\sqrt{r}}\\) to \\(\\frac{A}{\\sqrt{r}}\\) . Interference from Multiple Sources If we have multiple sources (e.g., \\(N\\) sources), the waves from each source add together. This is called the principle of superposition: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\eta_i(x, y, t) $$ Each wave \\(\\eta_i\\) is generated by its own source, and we sum their heights at each point \\((x, y)\\) at time \\(t\\) . If the waves are in phase (their crests align), they reinforce each other. If they are out of phase (a crest meets a trough), they cancel each other out. What Are We Trying to Do? The task asks us to: 1. Choose a regular polygon (e.g., triangle, square, pentagon) and place wave sources at its vertices. 2. For each point on the water, calculate the total wave from all sources. 3. Visualize the interference patterns\u2014show where the waves reinforce and where they cancel. 4. Analyze how the patterns depend on the positions of the sources, amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . Solution in a Single Black Box Step-by-Step Solution: Interference Patterns on a Water Surface Step 1: Choose a Regular Polygon and Place the Sources We will choose an equilateral triangle (3 vertices) as our regular polygon to simplify the task and clearly demonstrate interference. Let\u2019s place the vertices of the triangle on the \\((x, y)\\) plane: - Vertex 1: \\((x_1, y_1) = (-1, 0)\\) - Vertex 2: \\((x_2, y_2) = (1, 0)\\) - Vertex 3: \\((x_3, y_3) = (0, \\sqrt{3})\\) The distance between any two vertices is 2 (the side length of the triangle). These coordinates are chosen so that the triangle is equilateral and symmetric about the origin. Step 2: Wave Equation and Superposition The equation for a wave from a single source is: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ where \\(r = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from source \\(i\\) at \\((x_i, y_i)\\) to the point \\((x, y)\\) . For three sources, the total wave is: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^3 \\eta_i(x, y, t) = \\sum_{i=1}^3 \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi_i) $$ Let\u2019s assume: - \\(A = 1\\) (same amplitude for all sources). - \\(\\lambda = 0.5 \\, \\text{m}\\) (wavelength), so \\(k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{0.5} = 4\\pi \\, \\text{rad/m}\\) . - \\(f = 1 \\, \\text{Hz}\\) (frequency), so \\(\\omega = 2\\pi f = 2\\pi \\times 1 = 2\\pi \\, \\text{rad/s}\\) . - \\(\\phi_i = 0\\) (all sources are in phase, for simplicity). Step 3: Analyze Interference Patterns 3.1 Constructive and Destructive Interference - Constructive Interference : Occurs when waves from all sources arrive at a point \\((x, y)\\) in phase, i.e., \\(k r_i - \\omega t + \\phi_i\\) differs by \\(2\\pi n\\) (where \\(n\\) is an integer) for all sources. Then the \\(\\cos\\) terms are all close to 1 (or -1), and the amplitudes add up. - Destructive Interference : Occurs when waves arrive out of phase, i.e., the phase difference is \\(\\pi + 2\\pi n\\) . Then the \\(\\cos\\) for one wave is 1, and for another -1, so they cancel each other out. 3.2 Dependence on Parameters - Position of Sources : If the sources are closer together, the patterns become more frequent (more interference regions). If farther apart, the patterns stretch out. - Wavelength \\(\\lambda\\) : A smaller \\(\\lambda\\) (larger \\(k\\) ) makes the patterns denser, as the waves oscillate more frequently. A larger \\(\\lambda\\) stretches the patterns. - Frequency \\(f\\) (or \\(\\omega\\) ) : Affects how the patterns change over time. A larger \\(\\omega\\) makes the patterns move faster. Step 4: Visualize Interference Patterns We\u2019ll use Python to plot the interference pattern at time \\(t = 0\\) . We\u2019ll create a grid of points \\((x, y)\\) and compute \\(\\eta_{\\text{sum}}(x, y, 0)\\) for each point. Python Code: Visualizing Interference Patterns import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi * 1.0 # Angular frequency (f = 1 Hz) phi = 0.0 # Initial phase # Coordinates of sources (vertices of an equilateral triangle) sources = [(-1, 0), (1, 0), (0, np.sqrt(3))] # Grid of points on the water surface x = np.linspace(-3, 3, 100) y = np.linspace(-3, 3, 100) X, Y = np.meshgrid(x, y) # Compute the total wave at t = 0 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) r = np.maximum(r, 0.01) # Avoid division by zero eta = (A / np.sqrt(r)) * np.cos(k * r - omega * 0 + phi) eta_sum += eta # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_sum, levels=50, cmap='seismic') plt.colorbar(label='Wave Height (m)') plt.scatter([s[0] for s in sources], [s[1] for s in sources], c='black', marker='o', label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Interference Patterns on Water Surface (t = 0)') plt.legend() plt.axis('equal') plt.show() Explanation of the Code - Parameters : We set \\(A\\) , \\(\\lambda\\) , \\(k\\) , \\(\\omega\\) , and \\(\\phi\\) for the waves. - Sources : The coordinates of the three sources form an equilateral triangle. - Grid : We create a grid of points \\((x, y)\\) in the region from -3 to 3 along both axes. - Total Wave : For each point, we compute the wave from each source and sum them. - Visualization : We use contourf to create a color map of the wave height. Red and blue regions indicate crests and troughs, while white regions show destructive interference. Step 5: Analyze the Results Patterns : The plot shows regions where the waves reinforce each other (bright red and blue spots) and where they cancel (white areas). Symmetry : The pattern is symmetric because the triangle is equilateral, and all sources are in phase. Parameter Dependence : Reducing \\(\\lambda\\) would make the patterns denser. Changing \\(\\phi\\) for one source would break the symmetry and alter the patterns. Step 6: Conclusions Interference patterns demonstrate how waves interact. Constructive interference creates regions of large oscillations, while destructive interference creates calm regions. These patterns depend on the positions of the sources, wavelength, and phase. In real life, such phenomena are important for studying waves (e.g., in optics, acoustics) and designing devices that use interference, such as antennas or sensors. Explanation of the Solution Step 1 : We chose an equilateral triangle for placing the sources to ensure the patterns are symmetric and visually clear. Step 2 : We used the wave equation and the principle of superposition to sum the waves from three sources. Step 3 : We explained constructive and destructive interference and how the patterns depend on parameters. Step 4 : We visualized the interference pattern using Python, showing regions of reinforcement and cancellation. Step 5 : We analyzed the patterns, noting their symmetry and dependence on parameters. Step 6 : We concluded with the significance of interference in physics and its applications. If you\u2019d like to add an animation of the patterns over time or adjust the parameters, let me know!","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-of-the-topic-interference-patterns-on-a-water-surface","text":"","title":"Explanation of the Topic: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#main-topic-what-is-interference","text":"Interference is a phenomenon that occurs when two or more waves overlap. In this task, we are dealing with waves on the surface of water, created by point sources (e.g., like dropping several pebbles into the water). When waves from different sources meet, they can either reinforce each other (constructive interference) or cancel each other out (destructive interference). This creates patterns on the water\u2014regions where the water oscillates strongly and regions where it remains almost still. Real-Life Example: If you drop two pebbles into a pond, circular waves will spread out from each pebble. In places where the crests of the waves align, the water will rise significantly (constructive interference). Where a crest from one wave meets a trough from another, the water will remain nearly still (destructive interference). This forms an interference pattern.","title":"Main Topic: What is Interference?"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-and-variables","text":"The task provides the equation for a wave generated by a single source: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Let\u2019s break down the variables and symbols: - \\(\\eta(x, y, t)\\) \u2014 This is the height of the wave (in meters) at a point with coordinates \\((x, y)\\) on the water surface at time \\(t\\) . It represents how much the water has risen or fallen due to the wave. - \\(A\\) \u2014 The amplitude of the wave (in meters). This is the maximum height of the wave near the source. A larger \\(A\\) means a stronger wave. - \\(r\\) \u2014 The distance from the wave source to the point \\((x, y)\\) (in meters). If the source is at \\((x_0, y_0)\\) , then: $$ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $$ - \\(\\frac{A}{\\sqrt{r}}\\) \u2014 The amplitude of the wave decreases with distance. Dividing by \\(\\sqrt{r}\\) accounts for the fact that the wave\u2019s energy spreads over a circular wavefront, so its intensity decreases with distance. - \\(k\\) \u2014 The wave number (in radians per meter, rad/m). It is related to the wavelength \\(\\lambda\\) (the distance between two crests): $$ k = \\frac{2\\pi}{\\lambda} $$ A smaller wavelength means a larger \\(k\\) , resulting in more frequent waves. - \\(\\omega\\) \u2014 The angular frequency (in radians per second, rad/s). It is related to the frequency \\(f\\) (the number of crests passing a point per second): $$ \\omega = 2\\pi f $$ A larger \\(\\omega\\) means the wave oscillates faster. - \\(t\\) \u2014 Time (in seconds). - \\(\\phi\\) \u2014 The initial phase (in radians). This is the starting shift of the wave. If \\(\\phi = 0\\) , the wave starts at its maximum. If \\(\\phi = \\pi\\) , it starts at its minimum. - \\(kr - \\omega t + \\phi\\) \u2014 The phase of the wave. It determines the stage of oscillation at point \\((x, y)\\) at time \\(t\\) . If the phase is \\(0\\) or \\(2\\pi\\) , it\u2019s a crest; if it\u2019s \\(\\pi\\) , it\u2019s a trough. - \\(\\cos(kr - \\omega t + \\phi)\\) \u2014 The cosine function describes the wave\u2019s oscillation. Since cosine varies from \\(-1\\) to \\(1\\) , the wave height varies from \\(-\\frac{A}{\\sqrt{r}}\\) to \\(\\frac{A}{\\sqrt{r}}\\) .","title":"Wave Equation and Variables"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-from-multiple-sources","text":"If we have multiple sources (e.g., \\(N\\) sources), the waves from each source add together. This is called the principle of superposition: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\eta_i(x, y, t) $$ Each wave \\(\\eta_i\\) is generated by its own source, and we sum their heights at each point \\((x, y)\\) at time \\(t\\) . If the waves are in phase (their crests align), they reinforce each other. If they are out of phase (a crest meets a trough), they cancel each other out.","title":"Interference from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-are-we-trying-to-do","text":"The task asks us to: 1. Choose a regular polygon (e.g., triangle, square, pentagon) and place wave sources at its vertices. 2. For each point on the water, calculate the total wave from all sources. 3. Visualize the interference patterns\u2014show where the waves reinforce and where they cancel. 4. Analyze how the patterns depend on the positions of the sources, amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) .","title":"What Are We Trying to Do?"},{"location":"1%20Physics/3%20Waves/Problem_1/#solution-in-a-single-black-box","text":"Step-by-Step Solution: Interference Patterns on a Water Surface Step 1: Choose a Regular Polygon and Place the Sources We will choose an equilateral triangle (3 vertices) as our regular polygon to simplify the task and clearly demonstrate interference. Let\u2019s place the vertices of the triangle on the \\((x, y)\\) plane: - Vertex 1: \\((x_1, y_1) = (-1, 0)\\) - Vertex 2: \\((x_2, y_2) = (1, 0)\\) - Vertex 3: \\((x_3, y_3) = (0, \\sqrt{3})\\) The distance between any two vertices is 2 (the side length of the triangle). These coordinates are chosen so that the triangle is equilateral and symmetric about the origin. Step 2: Wave Equation and Superposition The equation for a wave from a single source is: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ where \\(r = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from source \\(i\\) at \\((x_i, y_i)\\) to the point \\((x, y)\\) . For three sources, the total wave is: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^3 \\eta_i(x, y, t) = \\sum_{i=1}^3 \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi_i) $$ Let\u2019s assume: - \\(A = 1\\) (same amplitude for all sources). - \\(\\lambda = 0.5 \\, \\text{m}\\) (wavelength), so \\(k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{0.5} = 4\\pi \\, \\text{rad/m}\\) . - \\(f = 1 \\, \\text{Hz}\\) (frequency), so \\(\\omega = 2\\pi f = 2\\pi \\times 1 = 2\\pi \\, \\text{rad/s}\\) . - \\(\\phi_i = 0\\) (all sources are in phase, for simplicity). Step 3: Analyze Interference Patterns 3.1 Constructive and Destructive Interference - Constructive Interference : Occurs when waves from all sources arrive at a point \\((x, y)\\) in phase, i.e., \\(k r_i - \\omega t + \\phi_i\\) differs by \\(2\\pi n\\) (where \\(n\\) is an integer) for all sources. Then the \\(\\cos\\) terms are all close to 1 (or -1), and the amplitudes add up. - Destructive Interference : Occurs when waves arrive out of phase, i.e., the phase difference is \\(\\pi + 2\\pi n\\) . Then the \\(\\cos\\) for one wave is 1, and for another -1, so they cancel each other out. 3.2 Dependence on Parameters - Position of Sources : If the sources are closer together, the patterns become more frequent (more interference regions). If farther apart, the patterns stretch out. - Wavelength \\(\\lambda\\) : A smaller \\(\\lambda\\) (larger \\(k\\) ) makes the patterns denser, as the waves oscillate more frequently. A larger \\(\\lambda\\) stretches the patterns. - Frequency \\(f\\) (or \\(\\omega\\) ) : Affects how the patterns change over time. A larger \\(\\omega\\) makes the patterns move faster. Step 4: Visualize Interference Patterns We\u2019ll use Python to plot the interference pattern at time \\(t = 0\\) . We\u2019ll create a grid of points \\((x, y)\\) and compute \\(\\eta_{\\text{sum}}(x, y, 0)\\) for each point. Python Code: Visualizing Interference Patterns import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi * 1.0 # Angular frequency (f = 1 Hz) phi = 0.0 # Initial phase # Coordinates of sources (vertices of an equilateral triangle) sources = [(-1, 0), (1, 0), (0, np.sqrt(3))] # Grid of points on the water surface x = np.linspace(-3, 3, 100) y = np.linspace(-3, 3, 100) X, Y = np.meshgrid(x, y) # Compute the total wave at t = 0 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) r = np.maximum(r, 0.01) # Avoid division by zero eta = (A / np.sqrt(r)) * np.cos(k * r - omega * 0 + phi) eta_sum += eta # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_sum, levels=50, cmap='seismic') plt.colorbar(label='Wave Height (m)') plt.scatter([s[0] for s in sources], [s[1] for s in sources], c='black', marker='o', label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Interference Patterns on Water Surface (t = 0)') plt.legend() plt.axis('equal') plt.show() Explanation of the Code - Parameters : We set \\(A\\) , \\(\\lambda\\) , \\(k\\) , \\(\\omega\\) , and \\(\\phi\\) for the waves. - Sources : The coordinates of the three sources form an equilateral triangle. - Grid : We create a grid of points \\((x, y)\\) in the region from -3 to 3 along both axes. - Total Wave : For each point, we compute the wave from each source and sum them. - Visualization : We use contourf to create a color map of the wave height. Red and blue regions indicate crests and troughs, while white regions show destructive interference. Step 5: Analyze the Results Patterns : The plot shows regions where the waves reinforce each other (bright red and blue spots) and where they cancel (white areas). Symmetry : The pattern is symmetric because the triangle is equilateral, and all sources are in phase. Parameter Dependence : Reducing \\(\\lambda\\) would make the patterns denser. Changing \\(\\phi\\) for one source would break the symmetry and alter the patterns. Step 6: Conclusions Interference patterns demonstrate how waves interact. Constructive interference creates regions of large oscillations, while destructive interference creates calm regions. These patterns depend on the positions of the sources, wavelength, and phase. In real life, such phenomena are important for studying waves (e.g., in optics, acoustics) and designing devices that use interference, such as antennas or sensors.","title":"Solution in a Single Black Box"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-of-the-solution","text":"Step 1 : We chose an equilateral triangle for placing the sources to ensure the patterns are symmetric and visually clear. Step 2 : We used the wave equation and the principle of superposition to sum the waves from three sources. Step 3 : We explained constructive and destructive interference and how the patterns depend on parameters. Step 4 : We visualized the interference pattern using Python, showing regions of reinforcement and cancellation. Step 5 : We analyzed the patterns, noting their symmetry and dependence on parameters. Step 6 : We concluded with the significance of interference in physics and its applications. If you\u2019d like to add an animation of the patterns over time or adjust the parameters, let me know!","title":"Explanation of the Solution"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}